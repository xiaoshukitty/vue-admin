# React

### 生命周期

![1647917521595](C:\Users\Admin\AppData\Roaming\Typora\typora-user-images\1647917521595.png)

#### componentWillMount

render之前最后一次修改状态的机会

#### render

只能访问 this.props 和 this.state，不允许修改状态和 DOM 输出

#### componentDidMount *

成功 render 并渲染完成真实 DOM 之后触发，可以修改 DOM

```react
import React, { Component } from 'react'

export default class App extends Component {
    state={
        myname:'hello'
    }
    
    // UNSAFE_ 加这个就不报警告，不过并不安全(因为这个生命周期优先级比较低，会被高优先级的生命周期打断，会重新在执行一次)
    UNSAFE_componentWillMount(){
        console.log('将要把状态挂载到dom中,可以访问状态，修改',this.state.myname,document.getElementById('myname'));    
        // render(DOM 上树之前)之前最后一次修改状态的机会
        this.setState({
            myname:"HELLO"
        })

        // 初始化数据的作用
    }

    componentDidMount(){
        console.log('已经挂载完了',document.getElementById('myname'));
        // 数据请求 axios
        // 订阅函数调用
        // setInterval
        // 基于创建完的 dom 进行初始化，，，，BetterScroll(new BetterScroll)
    }

    render () {
        console.log('正在渲染');
        return (
            <div>
                <span id='myname'>{this.state.myname}</span>
            </div>
        )
    }
}

```



#### componentWillUpdate

不能修改属性和状态

#### componentDidUpdate

可以修改 DOM 

```react
import React, { Component } from 'react'
import axios from 'axios';
import BetterScrll from 'better-scroll'

export default class App extends Component {

    state = {
        myname: 'hello',
        list: []
    }

    componentDidMount () {
        axios.get('/test.json').then(res => {
            console.log(res.data.data.films);
            this.setState({
                list: res.data.data.films
            })
            // 访问
            // new BetterScrll('#wrapper')
        })

    }

    render () {
        console.log('render');
        return (
            <div>
                <button onClick={() => {
                    this.setState({
                        myname: '你好'
                    })
                }}>click</button>
                <span id='myname'>{this.state.myname}</span>

                <div id='wrapper' style={{ height: '150px', background: 'yellow', overflow: 'hidden' }}>
                    <ul>
                        {
                            this.state.list.map(item =>
                                <li key={item.filmId}>{item.name}</li>)
                        }
                    </ul>
                </div>
            </div>
        )
    }


    // UNSAFE_ 加这个就不报警告，不过并不安全(因为这个生命周期优先级比较低，会被高优先级的生命周期打断，会重新在执行一次)
    UNSAFE_componentWillUpdate () {
        console.log('正在更新', document.getElementById('myname').innerHTML);
    }

    componentDidUpdate (prevProps,prevState) {
        // prevProps 这个是父传子传递过来的 
        console.log('已经更新完毕了', document.getElementById('myname').innerHTML);
        // 更新后，想要获取 DOM 节点，更新,更新就会执行(缺点)


        console.log(prevState.list);
        if(prevState.list.length===0){
            // 防止多次更新 new BetterScrll('#wrapper')
            new BetterScrll('#wrapper')
        }
    }

}

```

#### shouldComponentUpdate

返回 false 会阻止 render 调用， 页面更新或者父传子会自动更细一次，scu 性能优化函数

```react
import React, { Component } from 'react'

export default class App extends Component {

    state = {
        myname: 'hello'
    }

    render () {
        console.log('render');
        return (
            <div>
                <button onClick={() => {
                    this.setState({
                        myname: '你好'
                    })
                }}>click</button>
                {this.state.myname}
            </div>
        )
    }
    
    // scu 性能优化函数

    // 页面更新或者父传子会自动更细一次
    shouldComponentUpdate(nextProps,nextState){
        // return false //阻止更新
        // return true //应该更新

        // this.state 老的状态
        // nextState 新状态
        // if(this.state.myname!==nextState.myname) {
        if(JSON.stringify(this.state)!==JSON.stringify(nextState)){
            return true
        }
        return false
    }

    UNSAFE_componentWillUpdate () {
        console.log('UNSAFE_componentWillUpdate');
    }

    componentDidUpdate () {
        console.log('componentDidUpdate');
    }
}

```

#### componentWillReceiveProps

更新阶段生命周期，只能在孩子组件里面使用这个生命周期，缺点(外部组件多次频繁更新传入多次不同的 props，会导致不必要的异步请求)

```react
import React, { Component } from 'react'

class Child extends Component {

  state = {
    title: ''
  }

  render () {
    return (
      <div>Child{this.state.title}</div>
    )
  }

  // 只能在孩子组件里面使用这个生命周期
  // 外部组件多次频繁更新传入多次不同的 props，会导致不必要的异步请求
  componentWillReceiveProps (nextProps) {
    // nextProps 父组件传过来的数据
    // 最先获得父组件传来的数据，可以利用属性进行 ajax 或者逻辑处理
    // 把属性转换成孩子自己的状态
    //  这个生命周期里面 this.props.text 拿到的数据是老的数据，不是更新后的数据
    // console.log('componentWillReceiveProps',this.props.text);
    console.log('componentWillReceiveProps', nextProps);

    this.setState({
      title: nextProps.text + 'hello '
    })
  }
}

export default class App extends Component {
  state = {
    text: '111'
  }
  render () {
    return (
      <div>
        {
          this.state.text
        }

        <button onClick={() => {
          this.setState({
            text: '222'
          })
        }}>click</button>
        <Child text={this.state.text} />
      </div>
    )
  }
}

```

#### componentWillUnmount

在删除组件之前进行清理操作，比如计时器和事件监听， componentWillUnmount 生命周期可以销毁 window 窗口(setInterval)上面的事件，三元表达式 和 &&运算，是不可以销毁 window 窗口(setInterval)上面的事件的

```react
import React, { Component } from 'react'

export default class App extends Component {
    state = {
        isCreated: true
    }
    render () {
        return (
            <div>
                <button onClick={() => {
                    this.setState({
                        isCreated: !this.state.isCreated
                    })
                }}>click</button>
                {/* {this.state.isCreated ? <Child /> : ''} */}
                {this.state.isCreated && <Child />}
            </div>
        )
    }
}

class Child extends Component {
    render () {
        return (
            <div>Child</div>
        )
    }

    componentDidMount = () => {
        window.onresize = () => {
            console.log('onreset');
        }

        this.timer = setInterval(() => {
            console.log('111');
        }, 100)
    }


    // componentWillUnmount 生命周期可以销毁 window 窗口(setInterval)上面的事件，三元表达式 和 &&运算，是不可以销毁 window 窗口(setInterval)上面的事件的
    componentWillUnmount = () => {
        console.log('componentWillMount');
        window.onresize = null

        clearInterval(this.timer)
    }

}

```

#### getDerivedStateFromProps

从props 中获取 state

```react
import React, { Component } from 'react'

export default class App extends Component {

    state = {
        myname: 'hello',
        myage: 18
    }

    // componentWillMount 初始化 只会执行一次

    //  static 静态方法里面没有 this
    static getDerivedStateFromProps (nextProps, nextState) {
        console.log(this);
        console.log('getDrivedStateFromProps', nextState.myname);
        return {
            myname: nextState.myname.substring(0, 1).toUpperCase() + nextState.myname.substring(1)
        }
    }

    render () {
        return (
            <div>
                <button onClick={() => {
                    this.setState({
                        myname: 'heihei'
                    })
                }}>click</button>
                {this.state.myname}-{this.state.myage}
            </div>
        )
    }
}

```

#### getSnapshotBeforeUpdate

获取更新之前

```react
import React, { Component } from 'react'
import './css/04-clear.css'

export default class App extends Component {
    state = {
        list: [1, 2, 3, 4, 5, 6, 7, 8, 9]
    }
    myref = React.createRef()

    getSnapshotBeforeUpdate = (prevProps, prevState) => {
        // 获取更新之前容器的高度
        // 获取容器高度
        console.log(this.myref.current.scrollHeight);
        return this.myref.current.scrollHeight
    }

    componentDidUpdate = (prevProps, prevState, value) => {
        // 获取更新之后容器的高度
        console.log(this.myref.current.scrollHeight,value);
        // scrollTop 要滚动的位置
        this.myref.current.scrollTop += this.myref.current.scrollHeight - value
    }



    render () {
        return (
            <div>
                <button onClick={() => {
                    this.setState({
                        list: [...[11, 12, 13, 14, 15, 16, 17, 18, 19], ...this.state.list]
                    })
                }}>邮件</button>
                <h1>邮箱应用</h1>
                <div ref={this.myref} style={{ height: '200px', overflow: 'auto' }}>
                    <ul>
                        {
                            this.state.list.map((item,index) =>
                                <li key={index} style={{ height: '100px', background: 'yellow' }}>{item}</li>)
                        }
                    </ul>
                </div>
            </div>
        )
    }
}

```



### React 性能优化

![1647936894247](C:\Users\Admin\AppData\Roaming\Typora\typora-user-images\1647936894247.png)

### React-redux

地址 https://github.com/ustbhuangyi/better-scroll/blob/master/README_zh-CN.md



### hooks

所以的 hooks 和带 use的要么在另外一个 hooks 中使用,要么在函数组件中使用,其他位置都不能使用

# Vue

# JS的数组和对象方法

地址	https://blog.csdn.net/qq_44890872/article/details/103324937

### 数组方法

####  Array.map

 此方法是给数组中的每项数据都添加一个方法，结果作为一个新的数组返回，并不会改变原来的数组。 

```js
        let arr =[1,2,3,4,5]
        let newArr=arr.map(x=>x*2)
        console.log('arr的值',arr);
        console.log('newArr的值',newArr);
```

####  Array.[forEach](https://so.csdn.net/so/search?q=forEach&spm=1001.2101.3001.7020) 

 此方法是给数组的每一项数据循环添加一个方法，和map不同的是，forEach改变原数组，没有返回值。 

```js
        let arr =[1,2,3,4,5]
        let newArr=[]
        arr.forEach(item=>{
            newArr.push(item*2)
        })
        console.log(newArr);
```

#### Array.filter

 此方法类似于筛选向方法中传入一个判断条件，将满足条件的值变成一个新的数组返回。 不会改变原数组

```js
          let arr =[1,2,3,4,5]
          let newArr=arr.filter(item=>{
              return item>2
          })
          console.log('newArr',newArr);
          console.log('arr',arr);
```

#### Array.every

 此方法是将所有元素进行判断返回一个布尔值，如果所有元素都满足判断条件的话，则返回true，如果不满足就返回 false。遍历数组每一项，若全部为true，才返回true ,否则返回false 

```js
         let arr = [1, 2, 3, 4, 5]
         let newArr=arr.every(value=>{
             return value>6
         })
         let newArr2=arr.every(value=>{
             return value<6
         })
         console.log('数组里面的值都大于6吗',newArr);
         console.log('数组里面的值都小于6吗',newArr2);
```

#### Array.some

此方法和every类似，唯一区别就是some遍历数组中的每一项，若其中一项为true,则返回值是true，every遍历数组每一项，若全部为true，才返回true ,否则返回false。

```js
         let arr = [1, 2, 3, 4, 5]
         let newArr=arr.some(value=>{
             return value>4
         })
         let newArr2=arr.some(value=>{
             return value<6
         })
         console.log('数组里面的值都大于6吗',newArr);
         console.log('数组里面的值都小于6吗',newArr2);
```

#### Array.reduce

reduce 为数组中的每一个元素依次执行回调函数，不包括数组中被删除或从未被赋值的元素，接受四个参数：初始值（或者上一次回调函数的返回值），当前元素值，当前索引，调用 reduce 的数组。可以用来写求和求积。

```js
        let arr = [1, 2, 3, 4, 5, 10]
        let newArr = (a, b) => {
            console.log('a',a);
            console.log('b',b);
            return a + b
        }
        let sum =arr.reduce(newArr)
        console.log(sum);
```

#### Array.push

此方法用来向数组末尾添加一个或多个元素，返回新增后数组的长度。

```js
        let arr = [1, 2, 3, 4, 5]
        let newArr=arr.push(1,23,6)
        console.log('我是新增玩数组的长度',newArr);
        console.log('我是新增后的数组',arr);
        console.log(arr);
```

#### Array.pop

此方法删除数组中的最后一位元素，并返回数组，改变数组的长度。

```js
        let arr = [1, 2, 3, 4, 5]
        arr.pop()
        console.log('我是删除后数组的长度',arr.length);
        console.log('我是删除后数组',arr);
```

#### Array.shift

此方法删除数组中的第一个元素，并返回数组，此方法会改变数组长度。

```js
        let arr = [1, 2, 3, 4, 5]
        arr.shift()
        console.log('我是删除后数组的长度',arr.length);
        console.log('我是删除后数组',arr);
```

#### Array.unshift

此方法向数组前添加一个或多个元素，并返回数组，此方法会改变数组长度。

```js
        let arr = [1, 2, 3, 4, 5]
        arr.unshift(6,7,8)
        console.log('我是新增后数组的长度',arr.length);
        console.log('我是新增后数组',arr);
```

#### Array.isArray

此方法是用来判断一个对象是不是数组，是的话返回true，不是返回false。

```js
        let arr = [1, 2, 3, 4, 5]
        let bol=Array.isArray(arr)
        console.log('判断当前的数组是返回true还是false----',bol);
```

#### Array.concat

此方法是一个可以将多个数组合并成一个数组的方法。

```js
        let arr = [1, 2, 3, 4, 5]
        let newArr = [6, 7, 8, 9, 10]
        let arr2 =arr.concat(newArr)
        console.log(arr2);
        console.log('我是两个数组合并后的新数组',arr2);
```

#### Array.toString

此方法是用来将数组转变为字符串格式。

```js
        let arr = [1, 2, 3, 4, 5]
        let string=arr.toString()
        console.log(string);
        console.log(typeof(string));
```

#### Array.join

此方法也是将数组转换为字符串，但和toString不同的是join可以设置元素之间的间隔。

```js
        let arr = [1, 2, 3, 4, 5]
        let string =arr.join('-')
        console.log(string);
        console.log(typeof(string));
```

#### Array.splice

​    万能的方法可以实现数组的增、删、改。

​    删数组内的元素：

​    新增数组内的元素：更改的时候传的第二个参数为0表示不删除

​    更改数组中的元素：更改的时候第一个参数为1，表示从下标为1的地方开始，第二个参数传入1，表示删除1个元素，第三个参数为6表示在数组的下标为1的后面添加6

```js
        let arr = [1, 2, 3, 4, 5]
        let newArr=arr.splice(1,2)
        let newArr2=arr.splice(1,0,6)
        let newArr3=arr.splice(1,1,6)
        console.log('删除后的数组',arr);
        console.log('被删除的数组',newArr);
        console.log('新增后的数组',arr);
        console.log('更改后的数组',arr);
```

#### Array.slice

此方法返回从原数组中指定开始下表到结束下表之间的项组成的新数组（ 原数组不变） 截取数组。

```js
        let arr = [1, 2, 3, 4, 5]
        let newArr = arr.slice(0, 3)
        console.log(arr); //原数组 
        console.log(newArr); // 被截取后的数组
```

#### Array.includes

此方法用来判断数组中是否有传入的元素，有的话返回true，没有的话返回false。

```js
        let arr = [1, 2, 3, 4, 5]
        let bol=arr.includes(1)
        let bo2=arr.includes(6)
        console.log(bol);
        console.log(bo2);
```

#### Array.indexOf

从数组的开头向后查找， 接受两个参数， 要查找的项和查找起点的位置索引。

```js
        let arr = [1, 2, 3, 4, 5]
        let num = arr.indexOf(5, 2)
        console.log(num);
```

#### Array.sort

按指定的参数对数组进行排序， 返回的值是经过排序后的数组（ 无参， 函数）

```js
        var arr = [1, 'q', 3, 6, 2, 'a', 9]
        console.log(arr); //原数组
        var arr1 = arr.sort()
        console.log(arr1); //返回的是排序后的数组
        console.log('---------------');
        console.log(arr); //原数组变成新数组
```

#### Array.fill()

​    此方法用来替换数组中的元素， 会改变原数组。 接受三个参数， 第一个参数为替换的值， 如果只传入一个值会吧数组中的值全部替换。

​    第二个参数是标记为从第几个位置开始替换,会从标记的位置开始把后面的元素全部替换。

​    第三个参数是结束时的索引。

```js
        let arr = [1, 2, 3, 4, 5]
        let newArr = arr.fill(1)
        let newArr1 = arr.fill(1, 3)
        let newArr3 = arr.fill(1, 2, 4)
        console.log(arr); //原数组
        console.log(newArr); //替换后的数组
        console.log(newArr1); //替换后的数组
        console.log(newArr2); //替换后的数组
```

####  **flat** ()

可以将多维数组转化成一维数组  其中使用`Infinity`作为`flat`的参数，使得无需知道被扁平化的数组的维度。 

```js
 const deps = {
            '采购部': [1, 2, 3],
            '人事部': [5, 8, 12],
            '行政部': [5, 14, 79],
            '运输部': [3, 64, 105],
        }
        let member = Object.values(deps).flat(Infinity);
        console.log(member) //-------(12) [1, 2, 3, 5, 8, 12, 5, 14, 79, 3, 64, 105] flat方法不支持IE浏览器。
```

#### new Set()

所有元素都是唯一的，没有重复的值，集合

```js
        let deps = ['a', 'b', 'd', 'c', 'a', 'd', 'b', 'c', 's']
        let member = [...new Set(deps)]
        console.log(member);  //---------(5) ['a', 'b', 'd', 'c', 's']
```





### 对象方法

####  Object.values

此方法用将对象转换成数组

```js
var info = {
            'input': '1231',
            'input1': '你好',
            'input2': '你好吗',
        }
        
        console.log(Object.values(info));
```

![1652665457403](C:\Users\Admin\AppData\Roaming\Typora\typora-user-images\1652665457403.png)

#### Object.assign

此方法用于克隆对象， 传入两个参数， 第一个参数为原对象， 第二个参数为需要克隆的对象。 会合并为一个新的对象， 改变第一个参数的对象。

```js
        let obj = {
            naem: '小明',
            age: 18
        }
        let newObj = {
            gender: '男',
            like: '唱,跳,rap'
        }
        let object = Object.assign(obj, newObj)
        console.log(obj); //原对象
        console.log(newObj); //要克隆的对象
        console.log(object); // 克隆后的对象
```

#### Object.is

​    此方法是用来比较的接受两个参数， 第一个参数是需要比较的第一个值， 第二个参数是需要比较的第二个值。

​    返回值： 布尔值， 如果两个值相同返回true， 不相同返回false。

​    注意， 该函数与 == 运算符不同， 不会强制转换任何类型，

​    应该更加类似于 **= == ，但值得注意的是它会将 + 0 和 - 0 视作不同值 **

```js
        let obj = 1
        let newObj = 1
        let newObj1 = 2
        let object = Object.is(obj, newObj)
        let object1 = Object.is(obj, newObj1)
        console.log(object);
        console.log(object1);
```

#### Object.keys

此方法是用来获取对象的key值的。 返回一个包含key值的数组。

```js
        let obj = {
            naem: '小明',
            age: 18
        }
        let object = Object.keys(obj)
        console.log(object); //获取到的key
```

#### Object.defineProperty

defineProperty为设置对象的属性的属性特征 value设置属性名， enumerable设置该属性是否可以被枚举。 未设置的枚举的属性不能被for in遍历和keys获取。

​    该方法接受三个参数， 第一个参数为要加入属性的对象， 第二个参数为属性的key值， 第三个参数为一个对象。

```js
        let a = {}
        let b = {}
        Object.defineProperty(a, 'name', { //a 是哪一个对象，name 是传入的属性的 key 的名字
            value: 'kong',
            enumerable: true //该属性是否可枚举
        })
        console.log(a);
        console.log(b);
```

#### Object.defineProperties

可添加多个属性, 与Object.defineProperty() 对应。

```js
        let a = {}
        let b = {}
        Object.defineProperties(a, { //a 是哪一个对象，
            naem: { //name 是传入的属性的 key 的名字
                value: 'kong',
                enumerable: true //该属性是否可枚举
            },
            age: {
                value: 20,
                enumerable: true //该属性是否可枚举
            }
        })
        console.log(a);
        console.log(b);
```

#### Object.isPrototypeOf

此方法是用来检查一个对象是否存在另一个对象的原型链中。

```js
        function Obj() {} //创建一个构造函数
        let b = new Obj() //new 一个新对象赋值给 b
        console.log(Obj.prototype.isPrototypeOf(b)); //检查 b 对象是否存在于 Obj 对象的原型链中
```

#### Object.freeze  

 冻结一个对象 - 不能添加新属性，不能删除已有属性，不能修改已有属性，不能修改原型，不能修改已有属性的可枚举，可配置性，可写性





### 字符串方法

#### startsWith

startsWith()方法用来判断当前字符串是否是以另外一个给定的子字符串“开头”的，根据判断结果返回 true 或 false。

```js
var str = "To be, or not to be, that is the question.";

alert(str.startsWith("To be"));         // true
alert(str.startsWith("not to be"));     // false
alert(str.startsWith("not to be", 10)); // true

```

#### 1-9随机变化数组

```js
var str = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
function roa(arr) {//arr为可能出现的元素集合
  var temp = []; //temp存放生成的随机数组        　
  var count = arr.length;
  for(i = 0; i < count; i++) {
    var num = Math.floor(Math.random() * arr.length); //生成随机数num
    temp.push(arr[num]); //获取arr[num]并放入temp
    arr.splice(num, 1);
  }
  return temp;
}
console.log(roa(str))
```



## 数据类型



### 判断数据类型

地址	https://segmentfault.com/a/1190000037747875

```js
1、typeof
	typeof是一个操作符，右侧跟一个一元表达式，返回这个表达式的数据类型，以字符串的形式表示
    
2、instanceof
	instanceof来判断A是否为B的实例，表达为A instanceof B，返回一个布尔值。instanceof的原理是通过检测对象的原型链上是否含有类型的原型。

3、constructor
	JS规定，每个构造函数都会有一个prototype属性，即为构造函数的原型对象，而原型对象中会有一个constructor属性指回到构造函数。当利用构造函数创建新对象时，原型上的constructor属性也会被遗传到新创建的对象上，从原型链的角度讲，构造函数也代表了对象的类型。
    
4、Object.prototype.toString.call()
	toString()方法是Object原型上的方法，调用此方法，返回格式为[object,xxx]，xxx即为判断的结果。对于Object对象可以直接调用Object.prototype.toString()，对于其他数据类型，需要通过.call()来调用。
```



#### 数组

```js
1，要判断的数组 instanceof Array	// 返回一个布尔值(true 是数组)
2，Array.isArray (要判断的数组)	// 返回一个布尔值(true 是数组)
```
#### 对象

```js
1，要判断的对象 instanceof Object	// 返回一个布尔值(true 是对象)
```

#### 其他数据

```js
//	constructor
console.log(new Number(1).constructor == Number);//true
console.log(new String(1).constructor == String);//true
console.log(true.constructor == Boolean);//true
console.log(new Object().constructor == Object);//true
console.log(new Error().constructor == Error);//true

------------------------------------------------------

//	Object.prototype.toString.call()
console.log(Object.prototype.toString({}));//[object Object]
console.log(Object.prototype.toString.call(''));//[object String]
console.log(Object.prototype.toString.call(1));//[object Number]
console.log(Object.prototype.toString.call(true));//[object Boolean]
console.log(Object.prototype.toString.call(undefined));//[object Undefined]
console.log(Object.prototype.toString.call(null));//[object Null]
console.log(Object.prototype.toString.call(Symbol()));//[object Symbol]
console.log(Object.prototype.toString.call(new Error()));//[object Error]
```







## 依赖包

```
better-scroll	---	一个移动端滚动的解决方案
	地址	https://github.com/ustbhuangyi/better-scroll/tree/master
	详细地址	https://blog.csdn.net/weixin_37719279/article/details/82084342

mescroll.js	---	H5端 运行的下拉刷新和上拉加载插件
	地址	http://www.mescroll.com/api.html

http://www.5cv.top/  -- 小工具

https://doc.vux.li/zh-CN/ --vux

https://cubic-bezier.com/#.17,.67,.4,1.28 -- 曲线工具

https://www.uviewui.com/components/intro.html -- uview

https://mobile.ant.design/ -- ant移动端

http://caibaojian.com/react/webpack.html -- reactWebpack

https://www.naiveui.com/zh-CN/os-theme/components/input -- Naive UI

https://blog.csdn.net/xiejnpeng/article/details/111400199	--中国省市区级联数据

	
```



# 工具

### 地图选点 

https://mapapi.qq.com/web/mapComponents/locationPicker/v/index.html?search=1&type=1&key=OEUBZ-N35A6-WVBSU-EUSRK-GQSCS-UOBYL&referer=myapp

```

```



## 嘿嘿

### 拷贝

地址	https://www.jianshu.com/p/35d69cf24f1f

因为对象是引用类型，所以直接赋值对象给新变量，那么新变量指向的内存和原对象是一样的。所以我们通过浅拷贝和深拷贝实现开辟自己的内存空间。而浅拷贝只拷贝一层，深拷贝拷贝全部。

#### 浅拷贝

 **浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存** 

slice()、concat()、Array.from()、… 操作符：只能实现一维数组的深拷贝

```js
// 1.建一个对象
        var obj = {
            name: "北极光之夜。",
            like: "aurora",
        };
        //  方法1
        // 第一种是主要利用 for in 遍历原对象的属性。
        // 2. 封装一个函数，实现传入一个对象返回一个拷贝后的新对象
        function cloneObj(obj) {
            let clone = {};
            // 3.用 for  in 遍历obj的属性
            for (let i in obj) {
                clone[i] = obj[i];
            }
            return clone;
        } 

	// 方法二
    // Object.keys() 方法会返回一个由一个给定对象的自身可枚举属性组成的数组。
            function cloneObj(obj) {
                let clone = {};
                for (let [key, value] of Object.entries(obj)) {
                    clone[key] = value;
                }
                return clone;
            } 

	// 方法三
	// Object.entries()方法返回一个给定对象自身可枚举属性的键值对数组。
        function cloneObj(obj) {
            let clone = {};
            for (let [key, value] of Object.entries(obj)) {
                clone[key] = value;
            }
            return clone;
        } 
	
	// 方法四
	// 可用Object.getOwnPropertyNames（）配合forEach循环
    // Object.getOwnPropertyNames（）返回一个由它的属性构成的数组。
        function cloneObj(obj) {
            let clone = {};
            Object.getOwnPropertyNames(obj).forEach(function (item) {
                clone[item] = obj[item];
            });
            return clone;
        }

 // 4.执行函数，将得到一个新对象
        var clone = cloneObj(obj);
        // 5.更改 obj 属性值
        obj.like = "wind";
        // 6.输出
        console.log(clone); //这个不会改变 clone 里面的 like 属性

 

```



#### 深拷贝

 **深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象。**

Object：Object.assign()、… 操作符：只能实现一维对象的深拷贝 

JSON.parse(JSON.stringify(obj))：可实现多维对象的深拷贝，但会忽略 undefined 、 任意的函数 、Symbol 值

```js
// 方法一
// 1.建一个对象
        var obj = {
            name: "北极光之夜。",
            like: "aurora",
            age: {
                a: 1,
                b: 2,
            },
        };

        // 2. 封装一个函数，实现传入一个对象返回一个拷贝后的新对象
        function cloneObj(obj) {
            let clone = {};
            for (let i in obj) {
                // 如果为对象则递归更进一层去拷贝
                if (typeof obj[i] == "object" && obj[i] != null) {
                    clone[i] = cloneObj(obj[i]);
                } else {
                    clone[i] = obj[i];
                }
            }
            return clone;
        }
        // 4.执行函数，将得到一个新对象
        var clone = cloneObj(obj);
        // 5.更改 obj 属性值
        obj.age.a = "666";
        // 6.输出
        console.log(clone);

// 方法二
// 如果对象里面有数组怎么办，数组也跟对象一样是引用类型，那么我们可以在开头加个判断它是对象还是数组，数组的话赋空数组，一样遍历拷贝：
        var obj = {
            name: "北极光之夜。",
            like: "aurora",
            age: {
                a: [1, 2, 3],
                b: 2,
            },
        };

        // 2. 封装一个函数，实现传入一个对象返回一个拷贝后的新对象
        //  Array.isArray(obj) 和 obj instanceof Array 都可以判断是否是数组
        function cloneObj(obj) {
            // 先判断 obj 是否为数组
            // if (obj instanceof Array) {
            if (Array.isArray(obj)) {
                var clone = [];
            } else {
                var clone = {};
            }
            for (let i in obj) {
                // 如果为对象则递归更进一层去拷贝
                if (typeof obj[i] == "object" && obj[i] != null) {
                    clone[i] = cloneObj(obj[i]);
                } else {
                    clone[i] = obj[i];
                }
            }
            return clone;
        }
        // 4.执行函数，将得到一个新对象
        var clone = cloneObj(obj);
        // 5.更改 obj 属性值
        obj.age.a[1] = "666";
        // 6.输出
        console.log(clone);


// 方法三
// … 操作符演示
var obj1 = {
    name: "张三",
    age: 20,
    speak: function () {
        console.log("我是" + this.name);
    }
};
var obj2 = {
    ...obj1
};
// 当修改obj2的属性和方法的时候，obj1相应的属性和方法不会改变
obj2.name = "李四";
console.log(obj1);
console.log(obj2);


// 方法四
// JSON.parse(JSON.stringify(obj))：可实现多维对象的深拷贝，但会忽略 undefined 、 任意的函数 、Symbol 值
var obj1 = {
    name: "张三",
    age: 20,
    birthday: {
        year: 1997,
        month: 12,
        day: 5
    },
    speak: function () {
        console.log("我是" + this.name);
    }
};

var obj2 = JSON.parse(JSON.stringify(obj1));

// 当修改obj2的属性和方法的时候，obj1相应的属性和方法不会改变
obj2.name = "李四";
console.log(obj1);
console.log(obj2);

```

深拷贝通用

```js
var obj1 = {
    name: "张三",
    age: 20,
    birthday: {
        year: 1997,
        month: 12,
        day: 5
    },
    speak: function () {
        console.log("我是" + this.name);
    }
};

var obj2 = deepClone(obj1);

// 当修改obj2的属性和方法的时候，obj1相应的属性和方法不会改变
obj2.name = "李四";
console.log(obj1);
console.log(obj2);

/**
 * 深拷贝通用方法
 * @param obj   需要拷贝的对象
 * @param has
 * @returns {any|RegExp|Date}
 */
function deepClone(obj, has = new WeakMap()) {
    // 类型检查
    if (obj == null) return obj;
    if (obj instanceof Date) return obj;
    if (obj instanceof RegExp) return obj;
    if (!(typeof obj == "object")) return obj;

    // 构造对象
    const newObj = new obj.constructor;

    // 防止自引用导致的死循环
    if (has.get(obj)) return has.get(obj);
    has.set(obj, newObj);

    // 循环遍历属性及方法
    for (let key in obj) {
        if (obj.hasOwnProperty(key)) {
            newObj[key] = deepClone(obj[key]);
        }
    }

    // 返回对象
    return newObj;
}

```



### 数据类型

#### 手写  instanceof 

原理： 判读的思路就是看右边变量的原型是否存在于左边变量的原型链上 

```js
  // 手写实现instanceof
        function myinstanceof(left, right) {
            let leftValue = left.__proto__;
            let rightValue = right.prototype;
            while (true) {
                if (leftValue === null) {
                    return false
                } else if (leftValue === rightValue) {
                    return true
                } else {
                    leftValue = leftValue.__proto__
                }
            }
        }
```

### this

    普通函数中调用，this指向window
    对象方法中调用，this指向当前对象
    call apply bind中调用， this指向被传入的对象
    class中的方法中调用， this指向实例对象
    箭头函数，this就是父级上下文中的this 
    
    改变 this 指向
    相同点:
    都可以改变函数内部的this指向.
    区别点:
    1.call 和 apply 会调用函数, 并且改变函数内部this指向.会自动执行
    2.call 和 apply 传递的参数不一样, call 传递参数 aru1, aru2..形式 apply 必须数组形式[arg]
    3.bind 不会调用函数, 可以改变函数内部this指向.要手动执行(后面加一个())
    主要应用场景:
    1.call 经常做继承.
    2.apply 经常跟数组有关系. 比如借助于数学对象实现数组最大值最小值
    3.bind 不调用函数,但是还想改变this指向. 比如改变定时器内部的this指向。
### 闭包

 函数内部也有限权访问另一个函数内部的变量 

 闭包函数：声明在一个函数中的函数，叫做闭包函数。 

  闭包：内部函数总是可以访问其所在的外部函数中声明的参数和变量，即使在其外部函数被返回（寿命终结）了之后。 

```js
function outerFn(){
  var i = 0; 
  function innerFn(){
      i++;
      console.log(i);
  }
  return innerFn;
}
var inner = outerFn();  //声明变量在函数内,外部函数的地址不同，每次调用开辟一块内存空间执行后结束只有相同地址变量值保留累加，不同地址从初始值开始。
inner();
inner();
inner();
var inner2 = outerFn();
inner2();
inner2();
inner2();   //1 2 3 1 2 3


function funA(){
  var a = 10;  // funA的活动对象之中;
  return function(){   //匿名函数的活动对象;
        alert(a);
  }
}
var b = funA();
b();  //10


function fn(){
   var arr = [];
   for(var i = 0;i < 5;i ++){
	 arr[i] = function(){
		 return i;
	 }
   }
   return arr;
}
var list = fn();
for(var i = 0,len = list.length;i < len ; i ++){
   console.log(list[i]());
}  //5 5 5 5 5


function fn(){
  var arr = [];
  for(var i = 0;i < 5;i ++){
	arr[i] = (function(i){
		return function (){
			return i;
		};
	})(i);
  }
  return arr;
}
var list = fn();
for(var i = 0,len = list.length;i < len ; i ++){
  console.log(list[i]());
}  //0 1 2 3 4

优点:
①保护函数内的变量安全 ，实现封装，防止变量流入其他环境发生命名冲突
②在内存中维持一个变量，可以做缓存（但使用多了同时也是一项缺点，消耗内存）
③匿名自执行函数可以减少内存消耗

缺点:
①其中一点上面已经有体现了，就是被引用的私有变量不能被销毁，增大了内存消耗，造成内存泄漏，解决方法是可以在使用完变量后手动为它赋值为null；
②其次由于闭包涉及跨域访问，所以会导致性能损失，我们可以通过把跨作用域变量存储在局部变量中，然后直接访问局部变量，来减轻对执行速度的影响
```

### 为什么data必须是一个函数

```
Vue 中的 data 必须是个函数，因为当 data 是函数时，组件实例化的时候这个函数将会被调用，返回一个对象，计算机会给这个对象分配一个内存地址，实例化几次就分配几个内存地址，他们的地址都不一样，所以每个组件中的数据不会相互干扰，改变其中一个组件的状态，其它组件不变
简单来说，就是为了保证组件的独立性和可复用性，如果 data 是个函数的话，每复用一次组件就会返回新的 data，类似于给每个组件实例创建一个私有的数据空间，保护各自的数据互不影响
```

###  promise 

 promise是一个[构造函数](https://so.csdn.net/so/search?q=构造函数&spm=1001.2101.3001.7020)，自身有all，resolve，reject等方法，原型上有then，catch等方法。并且它new的实例对象特包含这些方法。通常将他包在一个函数中然后返回一个promise对象。 

地址 https://blog.csdn.net/sunlando/article/details/108631958

```js
function Num() {
            var p = new Promise((resolve, reject) => {
                var n = 2;
                if (n > 3) {
                    resolve(n)
                } else {
                    reject('数字太小了')
                };
            });
            return p
        }
        Num()
            .then(data => {
                    console.log(data)
            		// 数字太小了
                },
                reason => {
                    console.log(reason)
                })

promise接收一个参数，是函数，并且传入两个参数：resolve，reject，分别表示异步操作执行成功后的回调函数和异步操作执行失败后的回调函数。从表面上看，Promise可以简化层层回调的写法，即解决回调地狱的问题，但实质上，Promise的精髓是“状态”，用维护状态、传递状态的方式来使得回调函数能够及时调用
reject的作用就是把Promise的状态变成"rejected",然后在then中执行“失败”的回调函数。
catch的效果是和写在then里第二个参数一样，但是它有另一个作用：在执行resolve的回调函数时，如果抛出错误，不会报错卡死js，而是进入catch方法中
```

reason是 .then 第二个参数  

![1652863245906](C:\Users\Admin\AppData\Roaming\Typora\typora-user-images\1652863245906.png)

#### 回调地狱

 一个异步请求套着一个异步请求，一个异步请求依赖于另一个的执行结果，使用回调的方式相互嵌套 

### element 上传图片

```js
<el-upload
        class="avatar-uploader"
        action="a"
        :auto-upload="true"
        :show-file-list="false"
        accept=".jpg,.png,jpeg"
        :http-request="upload"
        list-type="picture-card"
      />
      
<script>
       methods: {
         // 上传图片
			upload ( params) {
              console.log('params',params);
              //  接口获取 oss 配置
              getOss().then(res => {
                if (res.data.code == 0) {
                  var ossConfig = res.data.data
                  console.log('ossConfig:', ossConfig);
                  var key = ossConfig.dir + this._randomString(10) + '.png';
                  var _file = params.file;
                  if (!_file) {
                    return;
                  }
                  var formData = new FormData();
                  formData.append('key', key);
                  formData.append('policy', ossConfig.policy);
                  formData.append('OSSAccessKeyId', ossConfig.accessid);
                  formData.append('success_action_status', 200);
                  formData.append('signature', ossConfig.signature);
                  formData.append('id', 'WU_FILE_0');
                  formData.append('name', _file.name);
                  formData.append('type', _file.type);
                  formData.append('lastModified', _file.lastModifiedDate);
                  formData.append('size', _file.size);
                  formData.append('file', _file);
                  let imgUrl = ossConfig.domain + '/' + key;
                  console.log('图片地址',imgUrl);
                  console.log('formData:', formData);
                }
              })
            },
            _randomString (len) {
              //生成随机文件名函数
              var chars = 'ABCDEFGHJKMNPQRSTWXYZabcdefhijkmnprstwxyz2345678';
              var maxPos = chars.length;
              var pwd = this._getNowFormatDate(); //为文随机生成的件名前面加上日期,防止文件名重复
              for (var i = 0; i < len; i++) {
                pwd += chars.charAt(Math.floor(Math.random() * maxPos));
              }
              return pwd;
            },
            //获取年月日
            _getNowFormatDate () {
              var date = new Date();
              var spacer = '-';
              var year = date.getFullYear();
              var month = date.getMonth() + 1;
              var strDate = date.getDate();
              if (month >= 1 && month <= 9) {
                month = '0' + month;
              }
              if (strDate >= 0 && strDate <= 9) {
                strDate = '0' + strDate;
              }
              var currentDate = year + spacer + month + spacer + strDate;
              return currentDate;
            }
     }
 </script> 
```



### 图片下载	

```js
export function download(downloadName, url) { // downloadName 图片的名称。url 图片地址(oss 服务器)
  const tag = document.createElement('a');
  tag.setAttribute('download',downloadName)
  const image = new Image();
  // 如果为https图片 添加时间戳，防止浏览器缓存图片
  if(url.startsWith('https')){
    image.src = url + '?time=' + new Date().getTime();
  }else{
    image.src = url;
  }
  //重要，设置 crossOrigin 属性，
  image.setAttribute('crossOrigin', 'Anonymous');
  // 图片加载完成调用a标签点击事件下载图片
  image.onload = () => {
    tag.href = resolveBase64Image(image);
    tag.click();
  };
}
// 获取图片的base64数据
export function resolveBase64Image(image){
  // 创建画布
  const canvas = document.createElement('canvas');
  canvas.width = image.width;
  canvas.height = image.height;
  const ctx = canvas.getContext('2d');
  // 以图片为背景剪裁画布
  ctx.drawImage(image, 0, 0, image.width, image.height);
  // 获取图片后缀名
  const extension = image.src.substring(image.src.lastIndexOf('.') + 1).toLowerCase();
  // 某些图片 url 可能没有后缀名，默认是 png
  return canvas.toDataURL('image/' + extension, 1);
}

```



### vant 上传图片

```js
 <van-uploader 
   v-model="fileList"
   multiple :max-count="1" 
   upload-text="点击上传身份证正面" 
   :after-read="afterRead"
   />
       
 <script>
       methods: {
         afterRead(file) {
           let fileimg=file;
          this.upload(fileimg)
         },
         // 上传图片
			upload(params) {
                // ossConfg 获取 oss 配置接口
				ossConfg().then(res => {
					if (res.data.code == 0) {
						var ossConfig = res.data.data;
						var key = ossConfig.dir + this._randomString(10) + '.png';
						var _file = params.file;
						if (!_file) {
							return;
						}
						var formData = new FormData();
						formData.append('key', key);
						formData.append('policy', ossConfig.policy);
						formData.append('OSSAccessKeyId', ossConfig.accessid);
						formData.append('success_action_status', 200)
						formData.append('signature', ossConfig.signature);
						formData.append('id', "WU_FILE_0");
						formData.append('name', _file.name);
						formData.append('type', _file.type);
						formData.append('lastModified', _file.lastModifiedDate);
						formData.append('size', _file.size);
						formData.append('file', _file);
						let imgUrl = ossConfig.domain + '/' + key;
						// console.log(imgUrl, ossConfig.domain);
						axios.post(ossConfig.host, formData).then(res => {
							if (res.status == 200 && res.statusText == "OK") {
                this.fileList.url = imgUrl;
                // console.log(this.fileList.url,"this.fileList.url")
								// this.changeSave();
							} else {
								return Toast('网络波动，请稍后重试');
							}
						});
					}
				});
			},
            _randomString(len) { //生成随机文件名函数
				var chars = 'ABCDEFGHJKMNPQRSTWXYZabcdefhijkmnprstwxyz2345678';
				var maxPos = chars.length;
				var pwd = this._getNowFormatDate(); //为文随机生成的件名前面加上日期,防止文件名重复
				for (var i = 0; i < len; i++) {
					pwd += chars.charAt(Math.floor(Math.random() * maxPos));
				}
				return pwd;
     	 },
         //获取年月日
			_getNowFormatDate() {
				var date = new Date();
				var spacer = "-";
				var year = date.getFullYear();
				var month = date.getMonth() + 1;
				var strDate = date.getDate();
				if (month >= 1 && month <= 9) {
					month = "0" + month;
				}
				if (strDate >= 0 && strDate <= 9) {
					strDate = "0" + strDate;
				}
				var currentDate = year + spacer + month + spacer + strDate;
				return currentDate;
			},
     }
 </script>
```

### 3

#### 阻止事件冒泡

1,事件委托 ：将元素的绑定事件写起其父元素上，防止事件冒泡 

2, event.stopPropagation()  ：可以阻止事件冒泡，阻止父级元素的绑定事件 

#### 链接



1, 力扣	https://leetcode.cn/problemset/all/

2,小案例	https://github.com/newbee-ltd

​		https://www.vue-js.com/topic/58abbd21a9c1282817afc28d

3,nextjs	https://vercel.com/shuanking/nextjs

4,	https://flutter.dev/

5,	https://nextjs-shuanking.vercel.app/

6,	https://socket.io/get-started/

7,	https://www.webrtc.org.cn/category/basic/

8,	 https://chinese.freecodecamp.org/learn/javascript-algorithms-and-data-structures/

9,webview 使用 https://blog.csdn.net/weixin_49570809/article/details/111593737



### 扁平化数据转化成树形数据

```js
 let data = [
            { id: 639, name: "商品管理", type: 0, pId: 638, code: "1", domain: "" },
            { id: 640, name: "商品分类", type: 0, pId: 639, code: "2", domain: "" },
            { id: 642, name: "增加分类", type: 0, pId: 640, code: "3", domain: "" },
            { id: 645, name: "编辑分类", type: 0, pId: 640, code: "4", domain: "" },
            { id: 646, name: "消息管理", type: 0, pId: 655, code: "4", domain: "" },
        ]
 
 // 两层循环找出id和pId相同的放入到外层循环的children中
 // 但是此时要删除那些已经放入到children中的列表项，并删除那些children为空的属性
 // 才能得到最后的结果
 
         function toTree1(data) {
            let del = []
            data.forEach(el => {
                el.children = []
                data.forEach((item) => {
                    if (item.pId == el.id) {
                        el.children.push(item)

                        del.push(item.id) /dl.f/ 删除那些要推进列表中的即可这些是重复的item删除
                    }
                })
                // 删除那些children为空的数据
                if (el['children'].length == 0) {
                    delete el['children']
                }
            })
            // 过滤那些已经push到el.children中的
            let result = data.filter(item => !del.(includes)(item.id))
            return result
        }

 console.log(toTree1(data));




```

![1654865758538](C:\Users\Admin\AppData\Roaming\Typora\typora-user-images\1654865758538.png)

### 树形数据转换成扁平化数据

树形数据是取上面扁平化数据转化过来的数据

```js
let arr = [{
            "id": 1,
            "name": "部门1",
            "pid": 0,
            "children": [{
                    "id": 2,
                    "name": "部门2",
                    "pid": 1,
                    "children": []
                },
                {
                    "id": 3,
                    "name": "部门3",
                    "pid": 1,
                    "children": [{
                        "id": 4,
                        "name": "部门4",
                        "pid": 3,
                        "children": [{
                            "id": 5,
                            "name": "部门5",
                            "pid": 4,
                        }]
                    }]
                }
            ]
        }]

        function flattTree(data) {
            let res = []
            data.forEach(el => {
                if (el.children) {
                    console.log('el',el);
                    res.push(el, ...flattTree(el.children)) //递归
                    delete el['children']
                } else {
                    res.push(el)
                }

            })
            return res
        }
        let list = flattTree(arr)
        console.log(list);


```

结果

![企业微信20221012-143729@2x](/Users/shuhuan/Desktop/test/笔记/笔记配套图/企业微信20221012-143729@2x.png)



### 堆和栈 ---

https://juejin.cn/post/6844904050543034376#heading-21

 ![盗的大佬的图](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9d505ac5f51f4a9396504c18091971c7~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp) 

#### 宏任务

我们可以将每次执行栈执行的代码当做是一个宏任务(包括每次从事件队列中获取一个事件回调并放到执行栈中执行)， 每一个宏任务会从头到尾执行完毕，不会执行其他

由于`JS引擎线程`和`GUI渲染线程`是互斥的关系，浏览器为了能够使`宏任务`和`DOM任务`有序的进行，会在一个`宏任务`执行结果后，在下一个`宏任务`执行前，`GUI渲染线程`开始工作，对页面进行渲染

```js
第一次宏任务完成 → 页面渲染 → 第一次宏任务完成（包含上一次宏任务事件时，异步队列中加入的宏任务） → 页面渲染....
```

常见的宏任务

- 主代码块，
- setTimeout，
- setInterval
- setImmediate ()-Node
- requestAnimationFrame ()-浏览器

#### 微任务

我们已经知道`宏任务`结束后，会执行渲染，然后执行下一个`宏任务`， 而微任务可以理解成在当前`宏任务`执行后立即执行的任务

当一个`宏任务`执行完，会在渲染前，将执行期间所产生的所有`微任务`都执行完。

```js
第一次宏任务 → 第一次所有微任务 → 页面渲染 → 第二次宏任务（包含上一次宏任务事件时，异步队列中加入的宏任务）→ 第二次所有微任务 → 页面渲染....
```

常见微任务有：

- process.nextTick ()
- Promise.then()
- Object.observe
- catch
- finally
- MutationObserver

 ![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/1/18/16fb7adf5afc036d~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp) 



#### 总结

```js
1.主体代码（第一次事件循环开始，所有的script代码）作为宏任务进入任务执行栈，但在主线程执行之前要做一系列操作判断。

2.判断当前任务是同步还是异步，同步的由主线程在任务栈中按先进后出顺序（先局部上下文，再全局上下文）执行，异步判断是宏任务还是微任务。

3.异步中的宏任务放入异步的宏任务event Table（异步队列分两种，宏任务队列和微任务队列,event Table也一样），微任务进入微任务event Table，在回调函数注册之后，再次进入它们对应的队列。

4.当主线程的任务执行完后，会检查微任务队列是否有任务，如果有就执行，如此循环，知道微任务队列没有任务。

5.当前事件的微任务执行完后，开始执行下一次事件，即会执行宏任务队列中的宏任务，如此循环下去，直到没有任务。
```



#### 关于Promise

 `new Promise(() => {}).then()` ，我们来看这样一个Promise代码 , 前面的 `new Promise()` 这一部分是一个构造函数，这是一个同步任务 , 后面的 `.then()` 才是一个异步微任务，这一点是非常重要的 

```js
new Promise((resolve) => {
	console.log(1)
  resolve()
}).then(()=>{
	console.log(2)
})
console.log(3)
```

 上面代码输出`1 3 2` 



#### 关于 async/await 函数

 async/await本质上还是基于Promise的一些封装，而Promise是属于微任务的一种 , 所以在使用await关键字与Promise.then效果类似 

```js
setTimeout(() => console.log(4))

async function test() {
  console.log(1)
  await Promise.resolve()
  console.log(3)
}

test()

console.log(2)
```

上述代码输出`1 2 3 4`

可以理解为，`await` 以前的代码，相当于与 `new Promise` 的同步代码，`await` 以后的代码相当于 `Promise.then`的异步

#### async

```js
//async 函数
async function fn() {
    return new Promise((resolve, reject) => {
        resolve('成功的数据');
        // reject("失败的错误");
    });
}

const result = fn();

//调用 then 方法
result.then(value => {
    console.log(value);
}, reason => {
    console.warn(reason);
});

// 打印  成功的数据
```

#### await

```js
//创建 promise 对象
const p = new Promise((resolve, reject) => {
    resolve("用户数据");
    //reject("失败啦!");
})

//await 要放在 async 函数中.
async function fun() {
    try {
        let result = await p;
        console.log(result);
    } catch (e) {
        console.log(e);
    }
}

//调用函数
fun();


// 打印  用户数据

```

await 表达式的案例演示：async与await封装AJAX请求

```js
// 发送 AJAX 请求, 返回的结果是 Promise 对象
function sendAJAX(url) {
    return new Promise((resolve, reject) => {
        //1. 创建对象
        const x = new XMLHttpRequest();
        //2. 初始化
        x.open('GET', url);
        //3. 发送
        x.send();
        //4. 事件绑定
        x.onreadystatechange = function () {
            if (x.readyState === 4) {
                if (x.status >= 200 && x.status < 300) {
                    resolve(x.response);//成功
                } else {
                    reject(x.status);//失败
                }
            }
        }
    })
}


// async 与 await 测试
async function fun() {
    //发送 AJAX 请求 1
    let joke = await sendAJAX("接口请求地址");
    //发送 AJAX 请求 2
    let tianqi = await sendAJAX('接口请求地址')

    console.log(joke);
    console.error(tianqi);//为了区别数据，我这里用红色的error输出
}

// 调用函数
fun();

```



#### Promise配合 ajax 案例演示

```js
// 接口地址: https://api.apiopen.top/getJoke
const p = new Promise((resolve, reject) => {
    //1. 创建对象
    const xhr = new XMLHttpRequest();
    //2. 初始化
    xhr.open("GET", "https://api.apiopen.top/getJoke");
    //3. 发送
    xhr.send();
    //4. 绑定事件, 处理响应结果
    xhr.onreadystatechange = function () {
        if (xhr.readyState === 4) {
            //判断响应状态码 200-299
            if (xhr.status >= 200 && xhr.status < 300) {
                //表示成功
                resolve(xhr.response);
            } else {
                //如果失败
                reject(xhr.status);
            }
        }
    }
});

//指定回调
p.then(function (value) {
    console.log(value);
}, function (reason) {
    console.error(reason);
});

```



### js执行机制

https://juejin.cn/post/6844904050543034376#heading-21 地址链接	



#### 事件循环

（先同步-->异步-->微任务事件队列-->宏任务事件队列）

首先，执行栈开始顺序执行

判断是否为同步，异步则进入异步线程，最终事件回调给事件触发线程的任务队列等待执行，同步继续执行

执行栈空，询问任务队列中是否有事件回调

任务队列中有事件回调则把回调加入执行栈末尾继续从第一步开始执行

任务队列中没有事件回调则不停发起询问

 ![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/1/18/16fb7acab03b35fa~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp) 



```js
let setTimeoutCallBack = function() {
  console.log('我是定时器回调');
};
let httpCallback = function() {
  console.log('我是http请求回调');
}

// 同步任务
console.log('我是同步任务1');

// 异步定时任务
setTimeout(setTimeoutCallBack,1000);

// 异步http请求任务
ajax.get('/info',httpCallback);

// 同步任务
console.log('我是同步任务2');



首先，执行console.log('我是同步任务1')
接着，执行到setTimeout时，会移交给定时器线程，通知定时器线程 1s 后将 setTimeoutCallBack 这个回调交给事件触发线程处理，在 1s 后事件触发线程会收到 setTimeoutCallBack 这个回调并把它加入到事件触发线程所管理的事件队列中等待执行
接着，执行http请求，会移交给异步http请求线程发送网络请求，请求成功后将 httpCallback 这个回调交由事件触发线程处理，事件触发线程收到 httpCallback 这个回调后把它加入到事件触发线程所管理的事件队列中等待执行
再接着执行console.log('我是同步任务2')
至此主线程执行栈中执行完毕，JS引擎线程已经空闲，开始向事件触发线程发起询问，询问事件触发线程的事件队列中是否有需要执行的回调函数，如果有将事件队列中的回调事件加入执行栈中，开始执行回调，如果事件队列中没有回调，JS引擎线程会一直发起询问，直到有为止
定时触发线程只管理定时器且只关注定时不关心结果，定时结束就把回调扔给事件触发线程
异步http请求线程只管理http请求同样不关心结果，请求结束把回调扔给事件触发线程
事件触发线程只关心异步回调入事件队列
而我们JS引擎线程只会执行执行栈中的事件，执行栈中的代码执行完毕，就会读取事件队列中的事件并添加到执行栈中继续执行，这样反反复复就是我们所谓的事件循环(Event Loop)
```





###### 



## 小问题

### es6

#### 关于输入框非空的判断

```js
//没用 es6
if(value !== null && value !== undefined && value !== ''){
    //...
}

---------------------------------------------------

// es6
if((value??'') !== ''){
  //...
}
```

#### 关于异步函数的吐槽

```js
//没用 es6
const fn1 = () =>{
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      resolve(1);
    }, 300);
  });
}
const fn2 = () =>{
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      resolve(2);
    }, 600);
  });
}
const fn = () =>{
   fn1().then(res1 =>{
      console.log(res1);// 1
      fn2().then(res2 =>{
        console.log(res2)
      })
   })
}

---------------------------------------------------

const fn = async () =>{
  const res1 = await fn1();
  const res2 = await fn2();
  console.log(res1);// 1
  console.log(res2);// 2
}

// 补充
//但是要做并发请求时，还是要用到Promise.all()
const fn = () =>{
   Promise.all([fn1(),fn2()]).then(res =>{
       console.log(res);// [1,2]
   }) 
}
```



#### 页面

因为页面直接使用div 模版会有威胁，会被注入 javascript 脚本，所以不能使用 dangerouslySetInnerHTML 来渲染模版



## 面试题

### js执行机制

```js
function test() {
  console.log(1)
  setTimeout(function () { 	// timer1
    console.log(2)
  }, 1000)
}

test();

setTimeout(function () { 		// timer2
  console.log(3)
})

new Promise(function (resolve) {
  console.log(4)
  setTimeout(function () { 	// timer3
    console.log(5)
  }, 100)
  resolve()
}).then(function () {
  setTimeout(function () { 	// timer4
    console.log(6)
  }, 0)
  console.log(7)
})

console.log(8)



// 打印	1，4，8，7，3，6，5，2


JS是顺序从上而下执行
执行到test()，test方法为同步，直接执行，console.log(1)打印1
test方法中setTimeout为异步宏任务，回调我们把它记做timer1放入宏任务队列
接着执行，test方法下面有一个setTimeout为异步宏任务，回调我们把它记做timer2放入宏任务队列
接着执行promise，new Promise是同步任务，直接执行，打印4
new Promise里面的setTimeout是异步宏任务，回调我们记做timer3放到宏任务队列
Promise.then是微任务，放到微任务队列
console.log(8)是同步任务，直接执行，打印8
主线程任务执行完毕，检查微任务队列中有Promise.then
开始执行微任务，发现有setTimeout是异步宏任务，记做timer4放到宏任务队列
微任务队列中的console.log(7)是同步任务，直接执行，打印7
微任务执行完毕，第一次循环结束
检查宏任务队列，里面有timer1、timer2、timer3、timer4，四个定时器宏任务，按照定时器延迟时间得到可以执行的顺序，即Event Queue：timer2、timer4、timer3、timer1，依次拿出放入执行栈末尾执行 (插播一条：浏览器 event loop 的 Macrotask queue，就是宏任务队列在每次循环中只会读取一个任务)
执行timer2，console.log(3)为同步任务，直接执行，打印3
检查没有微任务，第二次Event Loop结束
执行timer4，console.log(6)为同步任务，直接执行，打印6
检查没有微任务，第三次Event Loop结束
执行timer3，console.log(5)同步任务，直接执行，打印5
检查没有微任务，第四次Event Loop结束
执行timer1，console.log(2)同步任务，直接执行，打印2
检查没有微任务，也没有宏任务，第五次Event Loop结束
```

#### 防抖

1. 执行一个函数
2. 执行这个函数的时候一段时间后如果有东东再次执行这个函数,则重新计时后在次调用

```js
        /**
         * 防抖
         * @param {function} fn 要防抖的函数
         * @param {delay} delay 延迟(类似于fps一样~)
         * return 执行函数
         */
        function debounce(fn, delay) {
          	//这样子建立了一个闭包,timer始终存在
            let timer
            return function (...args) {
                if (timer) {
                    clearTimeout(timer) //清除上一次的
                }
                timer = setTimeout(() => {
                    //传入的为[30,40,50....这种形式],所以不能单纯fn(args)
                    //不确定参数,加上参数形式为[....],就使用fn.apply(this.args);
                    fn.apply(this, args)
                }, delay)
            }
        }

        // 测试
        function task() {
            console.log('run task')
        }
        const debounceTask = debounce(task, 1000)
        window.addEventListener('resize', debounceTask)
```

#### 节流

一定时间内只执行一项任务

1. 执行一个函数
2. 执行这个函数的时候看看前面有没有执行过
3. 如果前面有执行过这个函数并且没有完成,那么本次任务就不执行

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title></title>
    <style>
        .box {
            width: 100px;
            height: 100px;
            background-color: red;
            position: relative;
            top: 100px;
        }
    </style>
</head>
<body>
    <div class="box">
    </div>
    <script>
        var box = document.querySelector(".box");
        window.onmousemove=throttleMy(function(e){
            box.style.left = e.pageX - (box.clientWidth) / 2 + "px";
            box.style.top = e.pageY - (box.clientHeight) / 2 + "px";
        },40)

        /**
         * @param {function} fn 要防抖的函数
         * @param {number} delay 延迟(类似于fps一样~)
         * return 执行函数
         */
        function throttleMy(fn, delay) {
            //这样子建立了一个闭包,timer始终存在
            var timer=null;
            return function (...args) {
                if (timer) {
                    return;
                }
                timer = setTimeout(function () {
                    //传入的为[30,40,50....这种形式],所以不能单纯fn(args)
                    //不确定参数,加上参数形式为[....],就使用fn.apply(this.args);
                    fn.apply(this, args);
                    timer=null;
                }, delay);
            }
        }
    </script>
</body>
</html>

```



### 算法

#### 排序

```js
 let arr = [3, 1, 2, 5, 4, 8, 9, 7, 6];
        let tang = 0;
        let ci = 0;
        for (let i = 0; i < arr.length - 1; i++) {
            let flag = true; // 假设每一次进来都排好了
            tang++;
            for (let j = 0; j < arr.length - 1 - i; j++) {
                ci++;
                if (arr[j] > arr[j + 1]) {
                    flag = false; // 如果两位比较还满足前面的比后面的大的时候，说明假设不成立
                    let temp = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = temp;
                }
            }
            if (flag == true) { // 最后判断一下，如果假设推翻不了，就停止运行。
                break;
            }
        }
        console.log("趟数：" + tang); // 4 趟
        console.log("次数：" + ci); // 26 次
        console.log(arr);
```



#### 二分查找法

```js
// 非递归算法
        function binary_search(arr, key) {
            debugger
            var low = 0
            var high = arr.length - 1;
            while (low <= high) {
                var mid = parseInt((high + low) / 2);
                if (key == arr[mid]) {
                    return mid;
                } else if (key > arr[mid]) {
                    // 目标元素大于中间值，取右边
                    low = mid + 1;
                } else if (key < arr[mid]) {
                    // 目标元素小于中间值，取左边
                    high = mid - 1;
                }
            }
            return -1;
        };

        var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 23, 44, 86];
        var result = binary_search(arr, 10);
        alert(result); // 9 返回目标元素的索引值 


// 递归算法
        function binary_search(arr, low, high, key) {
            if (low > high) {
                return -1;
            }
            var mid = parseInt((high + low) / 2);
            if (arr[mid] == key) {
                return mid;
            } else if (arr[mid] > key) {
                high = mid - 1;
                return binary_search(arr, low, high, key);
            } else if (arr[mid] < key) {
                low = mid + 1;
                return binary_search(arr, low, high, key);
            }
        };

        var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 23, 44, 86];
        var result = binary_search(arr, 0, 13, 10); 
				// 0 是默认为0，13 是数组的长度，10 是要找的数据
        alert(result); // 9 返回目标元素的索引值  
```

#### 求双数之和

```json
// 求2数之和
        let nums = [2, 3, 5, 7, 11, 15],
            target = 9
        let arrIndex = function (nums, target) {
            let map = new Map();
            // debugger
            for (var i = 0; i < nums.length; i++) {
                if (map.has(target - nums[i])) { 
                    //
                    return [map.get(target - nums[i]), i]
                }
                map.set(nums[i], i)
                // [{2,0},{3,1},{5,2}]
            }
            return [];
        }
        console.log(arrIndex(nums, target));
```



### 为什么key不能用索引

因为 diff算法 会通过 key 来比对,静态渲染用索引没有问题,但是修改值的时候会创建内容而不是复制(位移来拿到对应的值),用id来当key的话会复制(位移来拿到对应的值),用id来当 key 性能会比 索引 的性能好很多的

### diff算法 

diff算法(双指针比对法)  是比对 vnode(虚拟DOM) 下面的是真实DOM，需要把真实DOM转化为虚拟DOM

```js
<ul> // 老的
	<li style="background:yellow" key="d">d</li>
  <li style="background:blue" key="c">c</li>
  <li style="background:pink" key="b">b</li>
  <li style="background:red" key="a">a</li>
</ul>

<ul> //新的
  <li style="background:blue" key="c">c</li>
  <li style="background:pink" key="b">b</li>
  <li style="background:red" key="a" >a</li>
</ul>


//1，头部是同一个元素,拿老的开头元素和新的开头元素比对，一样的就走其他逻辑(下面)，然后老的元素索引++和新的元素索引++
//2，尾部是同一个元素,的尾部元素和新的尾部元素比对，一样的就走其他逻辑(下面)，然后老的元素索引--和新的元素索引--
// 3，交叉对比--老的开头和新的结尾对比，一样就其他的逻辑(下面)，然后老的元素索引++，新的元素索引--
// 4，交叉对比--老的结尾和新的开头对比，一样就其他的逻辑(下面)，然后老的元素索引--，新的元素索引++
// 5，//暴力比对---
// 5.1 创建旧元素的映射表，拿新的去和老的每一个去比对,没有的话就在老的开头新增一个,有的话就把这个老的拿出来放在开头然后在老的元素中把这个值设置为null，防止数组塌陷，全部比对完了,然后删除这个老的元素,

// 其他逻辑
// 1，老的元素的tag和新的元素tag是不是一样的，不一样的就把老的元素的tag 替换为新的元素的 tag，
// 2，比对文本。老的文本不等于新的文本的话，就把新的文本替换掉老的文本

// 每次比对，指针都会移动
```

#### watch 和 computed

computed 具有缓存机制，通过一个变量 dirty，为什么可以在实例中使用，是因为有 Object.defineProperty 来劫持，要有return

watch 执行是一个回调函数,写法不一样,可以异步

#### Vue 为什么是组件开发

优点 性能能高,组件的更新。复用 好维护

 组件三要素--- 属性 样式 插槽





## javascript

### 浏览器兼容

#### 浏览器类型的判断

```js
var ua = navigator.userAgent;
if (/firefox/i.test(ua)) {
    alert("你是火狐浏览器");
} else if (/chrome/i.test(ua)) {
    alert("你是谷歌浏览器");
} else if (/msie/i.test(ua)) {
    alert("你是IE5-IE10浏览器");
} else if ("ActiveXObject" in window) {
    alert("你是IE11浏览器");
}

```



### 观察者模式

 当对象之间存在一对多的依赖关系时，其中一个对象的状态发生改变，所有依赖它的对象都会收到通知，这就是观察者模式。在观察者模式中，只有两种主体：目标对象 (`Object`) 和 观察者 (`Observer`)。

目标对象 `Subject`:

- 维护观察者列表 `observerList` ———— 维护拥有订阅权限的弟子列表
- 定义添加观察者的方法 ———— 提供弟子购买订阅权限的功能
- 当自身发生变化后，通过调用自己的 `notify` 方法依次通知每个观察者执行 `update` 方法 ———— 发布对应任务后通知有订阅权限的弟子

观察者 `Observer` 需要实现 `update` 方法，供目标对象调用。`update`方法中可以执行自定义的业务逻辑 ———— 弟子们需要定义接收任务通知后的方法，例如去抢任务或任务不适合，继续等待下一个任务

```js
/* 观察者模式 */

        // 定义 观察者
        class Observer {
            constructor(name) {
                this.name = name;
            }
            update({
                taskType,
                taskInfo
            }) {
                // 假设任务分为日常 route 和 战斗 war
                if (taskType === 'router') {
                    console.log(`${this.name}不需要日常任务`);
                    return;
                }
                this.goToTaskHome(taskInfo);
            }
            goToTaskHome(info) {
                console.log(`${this.name}去任务大殿抢${info}任务`);
            }
        }

        // 定义目标对象
        class Subject {
            constructor() {
                this.observerList = [];
            }
            addObserver(observer) {
                this.observerList.push(observer);
            }
            notify(task) {
                console.log('发布五星任务',this.observerList);
                this.observerList.forEach(item => item.update(task));
            }
        }

        const subject = new Subject();
        const stu1 = new Observer('弟子1');
        const stu2 = new Observer('弟子2');

        // stu1 stu2 购买五星任务通知权限ß
        subject.addObserver(stu1);
        subject.addObserver(stu2);

        //任务殿发布五星战斗任务
        const warTask = {
            taskType: 'war',
            taskInfo: '猎杀开始'
        }

        // 任务殿通知购买权限的弟子
        subject.notify(warTask);

        //任务殿发布五星日常任务
        const routeTask = {
            taskType: 'route',
            taskInfo: '种树浇水'
        }

        subject.notify(routeTask);

        /*
            输出    
                战斗任务
                发布五星任务
                弟子1去任务大殿抢猎杀开始任务
                弟子2去任务大殿抢猎杀开始任务
                ---------------------------
                日常任务
                发布五星任务
                弟子1去任务大殿抢种树浇水任务
                弟子2去任务大殿抢种树浇水任务

        */
```



### 发布订阅模式

基于一个事件（主题）通道，希望接收通知的对象 `Subscriber` 通过自定义事件订阅主题，被激活事件的对象 `Publisher` 通过发布主题事件的方式通知各个订阅该主题的 `Subscriber` 对象。

因此发布订阅模式与观察者模式相比，发布订阅模式中有三个角色，发布者 `Publisher` ，事件调度中心 `Event Channel` ，订阅者 `Subscriber` 。

上面的文字有些难以理解，我们继续以弟子领取任务为栗子，宗门感觉把任务订阅放在任务大殿中有些繁琐，于是决定在任务大殿和弟子中间添加**中介**。弟子在中介中订阅其需要的任务类型，当任务大殿发布任务后，中介会将发布任务给对应的订阅者。

- 宗门任务大殿: 任务发布者 —— `Publisher`
- 中介功能 —— Event Channel
  - 维护任务类型，以及每种任务下的订阅情况
  - 给订阅者提供订阅功能 —— `subscribe` 功能
  - 当宗门发布任务后，中介会给所有的订阅者发布任务 —— `publish` 功能
- 弟子: 任务接受者 —— `Subscriber`

```js
/* 发布订阅模式 */

        class PubSub {
            constructor() {
                // 事件中心
                // 存储格式：warTask:[],routeTask:[]
                // 每种事件(任务)下存放其订阅者的回调函数
                // this.events = {};
                this.events = Object.create(null); // 这样写不会有原型链上的属性。
            }
            //订阅方法
            subscribe(type, cb) {
                if (!this.events[type]) {
                    this.events[type] = [];
                }
                this.events[type].push(cb);
                console.log(this.events,'订阅者的回调函数');
            }
            //发布任务
            publish(type, ...args) {
                if (this.events[type]) {
                    this.events[type].forEach(item => item(...args))
                }
            }
            //取消订阅方法
            unsubscribe(type, cb) {
                if (this.events[type]) {
                    const cbIndex = this.events[type].findIndex(e => e === cb)
                    if (cbIndex != -1) {
                        this.events[type].splice(cbIndex, 1);
                    }
                }
                if (this.events[type].length === 0) {
                    delete this.events[type];
                }
            }
            unsubscribeAll(type) {
                if (this.events[type]) {
                    delete this.events[type];
                }
            }
        }

        // 创建一个中介公司
        let pubsub = new PubSub();

        // 弟子1 订阅战斗任务
        pubsub.subscribe('warTask', function (taskInfo) {
            console.log("宗门殿发布战斗任务，任务信息:" + taskInfo);
        })
        // 弟子2 订阅日常任务
        pubsub.subscribe('routeTask', function (taskInfo) {
            console.log("宗门殿发布日常任务，任务信息:" + taskInfo);
        })
        // 弟子2 订阅全类型任务
        pubsub.subscribe('allTask', function (taskInfo) {
            console.log("宗门殿发布五星任务，任务信息:" + taskInfo);
        })

        // 发布战斗任务 
        pubsub.publish('warTask', '猎杀时刻')
        pubsub.publish('allTask', '猎杀时刻')

        // 发布日常任务
        pubsub.publish('routeTask', "种树浇水");
        pubsub.publish('allTask', "种树浇水");

        /*
            输出
                宗门殿发布战斗任务，任务信息:猎杀时刻
                宗门殿发布五星任务，任务信息:猎杀时刻
                宗门殿发布日常任务，任务信息:种树浇水
                宗门殿发布五星任务，任务信息:种树浇水
        */
```



### 观察者模式和发布--订阅模式区别

| 设计模式 | 观察者模式                                    | 发布订阅模式                                            |
| -------- | --------------------------------------------- | ------------------------------------------------------- |
| 主体     | Object观察者、Subject目标对象                 | Publisher发布者、Event Channel事件中心、Subscribe订阅者 |
| 主体关系 | Subject中通过observerList记录ObServer         | Publisher和Subscribe不想不知道对方，通过中介联系        |
| 优点     | 角色明确，Subject和Object要遵循约定的成员方法 | 松散耦合，灵活度高，通常应用在异步编程中                |
| 缺点     | 紧耦合                                        | 当事件类型变多时，会增加维护成本                        |
| 使用案例 | 双向数据绑定                                  | 事件总线EventBus                                        |



### axios

axios 中 get 请求必须要结构一层，并且参数必须是 params



### ajax

```js
var Ajax = {
    get: function (url, fn) {
        var xhr = new XMLHttpRequest();
        xhr.open('GET', url, true);
        xhr.onreadystatechange = function () {
            if (xhr.readyState == 4 && xhr.status == 200 || xhr.status == 304) {
                fn.call(this, xhr.responseText);
            }
        };
        xhr.send();
    },
    post: function (url, data, fn) {
        var xhr = new XMLHttpRequest();
        xhr.open("POST", url, true);
        xhr.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
        xhr.onreadystatechange = function () {
            if (xhr.readyState == 4 && (xhr.status == 200 || xhr.status == 304)) {
                fn.call(this, xhr.responseText);
            }
        };
        xhr.send(data);
    }
};

// 演示GET请求
Ajax.get("users.json", function (response) {
    console.log(response);
});

// 演示POST请求
Ajax.post("users.json", "", function (response) {
    console.log(response);
});

```

### Cookie

#### Cookie值设置函数

```js
/**
 * Cookie值设置函数
 * @param cname     cookie名称
 * @param cvalue    cookie值
 * @param exdays    过期天数
 */
function setCookie(cname, cvalue, exdays) {
    var d = new Date();
    d.setTime(d.getTime() + (exdays * 24 * 60 * 60 * 1000));
    var expires = "expires=" + d.toGMTString();
    document.cookie = cname + "=" + cvalue + "; " + expires;
}

```

#### Cookie值获取函数

```js
/**
 * Cookie值获取函数
 * @param cname     cookie名称
 * @returns {string}
 */
function getCookie(cname) {
    var name = cname + "=";
    var ca = document.cookie.split(';');
    for (var i = 0; i < ca.length; i++) {
        var c = ca[i].trim();
        if (c.indexOf(name) == 0) return c.substring(name.length, c.length);
    }
    return "";
}
```





## 基础校验



#### 金额校验

直接调用下面方法 传入金额 🌰 	this.checkAmt (20)

```js
    // 金额校验
   checkAmt (dPrice) {
      // 第一步：判断是否有非法字符
      for (var i = 0; i < dPrice.length; i++) {
        if (isNaN(parseInt(dPrice.charAt(i))) && dPrice.charAt(i) != "." && dPrice.charAt(i) != ",") {
          Toast(`请输入正确的金额！`)
          return false;
        }
      }
      // 第二步：如果存在小数点，判断是否仅有一个小数点
      if (dPrice.indexOf(".") != dPrice.lastIndexOf(".")) {
        return false;
      }
      // 第三步：判断金额是否为零
      var re = /,/g;
      var amt1 = dPrice.replace(re, "");
      var amt2 = parseFloat(amt1);
      if (amt2 <= 0) {
        return false;
      } else {
        // 第四步：判断金额小数点后是否超过两位 
        if (amt1.indexOf(".") != -1) {
          var str = amt1.substr(amt1.indexOf(".") + 1);
          if (str.length > 2) {
            return false;
          }
        }
        // 第五步：判断以零开头的金额，小数点是否在第一位
        if (amt1.charAt(0) == "0" && amt1.indexOf(".") != 1) {
          return false;
        }
        // 第六步：判断金额是否超过最大金额
        var temp = (amt1.indexOf(".") != -1) ? amt1.substring(0, amt1.indexOf(".")) : amt1;
        if (temp.length > 10) {
          return false;
        }
      }
      return true;
    },
```





## 省市区

#### 省市编码json

4位

https://cdn.cloudpnr.com/adapayresource/documents/Adapay%E7%9C%81%E5%B8%82%E7%BC%96%E7%A0%81%EF%BC%88%E5%9B%9B%E4%BD%8D%EF%BC%89.json



#### 省市区编码json

6位

https://cdn.cloudpnr.com/adapayresource/documents/Adapay%E7%9C%81%E5%B8%82%E5%8C%BA%E7%BC%96%E7%A0%81%EF%BC%88%E5%85%AD%E4%BD%8D%EF%BC%89.json



## http



### http缓存

#### 强制缓存

强制缓存分为两种情况，Expires和Cache-Control。

1，Expires（HTTP1.0）

​		Expires的值是服务器告诉浏览器的缓存过期时间（值为GMT时间，即格林尼治时间），即下一次请求时，如果浏览器端的当前时间还没有到达过期时间，则直接使用缓存数据。

2，Cache-Control（HTTP1.1）

​		服务器不是直接告诉浏览器过期时间，而是告诉一个相对时间Cache-Control=10秒，意思是10秒内，直接使用浏览器缓存。



#### 协商缓存

1，Last-Modified

- 浏览器请求静态资源demo.js
- 服务器读取磁盘文件demo.js，返给浏览器，同时带上文件上次修改时间 Last-Modified（GMT标准格式）
- 当浏览器上的缓存文件过期时，浏览器带上请求头`If-Modified-Since`（等于上一次请求的Last-Modified）请求服务器
- 服务器比较请求头里的`If-Modified-Since`和文件的上次修改时间。如果果一致就继续使用本地缓存（304），如果不一致就再次返回文件内容和Last-Modified。
- 循环请求。。

缺点

- 由于Last-Modified修改时间是GMT时间，只能精确到秒，如果文件在1秒内有多次改动，服务器并不知道文件有改动，浏览器拿不到最新的文件
- 如果服务器上文件被多次修改了但是内容却没有发生改变，服务器需要再次重新返回文件。



2，ETag

- 浏览器请求静态资源demo.js
- 服务器读取磁盘文件demo.js，返给浏览器，同时带上文件的唯一标识ETag
- 当浏览器上的缓存文件过期时，浏览器带上请求头`If-None-Match`（等于上一次请求的ETag）请求服务器
- 服务器比较请求头里的`If-None-Match`和文件的ETag。如果一致就继续使用本地缓存（304），如果不一致就再次返回文件内容和ETag。
- 循环请求。。



3，Cache-Control

- private: 客户端可以缓存
- public: 客户端和代理服务器都可缓存
- max-age=xxx: 缓存的内容将在 xxx 秒后失效
- no-cache: 需要使用对比缓存来验证缓存数据
- no-store: 所有内容都不会缓存，强制缓存，对比缓存都不会触发



4，缓存优先级

​		强制缓存的优先级高于协商缓存，Pragma的优先级高于Cache-Control

```
Pragma > Cache-Control > Expires > ETag > Last-Modified
```



#### 区别

​		强制缓存的弊端很明显，即每次都是根据时间来判断缓存是否过期；但是当到达过期时间后，如果文件没有改动，再次去获取文件就有点浪费服务器的资源了。协商缓存有两组报文结合使用









#### 常见请求头

```
Accept: text/html,image/*                                            浏览器可以接收的类型 
Accept-Charset: ISO-8859-1                                      浏览器可以接收的编码类型
Accept-Encoding: gzip,compress                               浏览器可以接收压缩编码类型 
Accept-Language: en-us,zh-cn                                浏览器可以接收的语言和国家类型
Host: www.lks.cn:80                                               		浏览器请求的主机和端口
If-Modified-Since: Tue, 11 Jul 2000 18:23:51 GMT   												某个页面缓存时间 
Referer: http://www.lks.cn/index.html                         					请求来自于哪个页面
User-Agent: Mozilla/4.0 compatible; MSIE 5.5; Windows NT 5.0   							浏览器相关信息
Cookie：                                                           浏览器暂存服务器发送的信息
Connection: close1.0/Keep-Alive1.1                          					HTTP请求的版本的特点
Date: Tue, 11 Jul 2000 18:23:51GMT                       										请求网站的时间
Allow:GET                                                     请求的方法 GET 常见的还有POST
Keep-Alive：5                                                            		连接的时间；5
Connection：keep-alive                                             					是否是长连接
Cache-Control：max-age=300                                   			缓存的最长时间 300s
```

#### 常见响应头

```
Location: http://www.lks.cn/index.html                          控制浏览器显示哪个页面 
Server:apache nginx                                                   服务器的类型 
Content-Encoding: gzip                                             服务器发送的压缩编码方式 
Content-Length: 80                                                服务器发送显示的字节码长度 
Content-Language: zh-cn                                         服务器发送内容的语言和国家名 
Content-Type: image/jpeg; charset=UTF-8                 服务器发送内容的类型和编码类型 
Last-Modified: Tue, 11 Jul 2000 18:23:51GMT           服务器最后一次修改的时间 
Refresh: 1;url=http://www.lks.cn                         控制浏览器1秒钟后转发URL所指向的页面 
Content-Disposition: attachment; filename=lks.jpg      服务器控制浏览器发下载方式打开文件 
Transfer-Encoding: chunked                                      服务器分块传递数据到客户端  
Set-Cookie:SS=Q0=5Lb_nQ; path=/search                服务器发送Cookie相关的信息 
Expires: -1                                     资源的过期时间，提供给浏览器缓存数据,-1永远过期 
Cache-Control: no-cache                     告诉浏览器，一定要回服务器校验，不管有没有缓存数据。 
Pragma: no-cache                                              服务器控制浏览器不要缓存网页   
Connection: close/Keep-AliveHTTP                           请求的版本的特点   
Date: Tue, 11 Jul 2000 18:23:51 GMT                       响应网站的时间 
ETag：“ihfdgkdgnp98hdfg”                源实体的标识(唯一标识，类似md5值，文件有修改md5就不一样)
```



#### http状态码

| 2XX  | 成功（这系列表明请求被正常处理了）                     |
| ---- | ------------------------------------------------------ |
| 200  | OK，表示从客户端发来的请求在服务器端被正确处理         |
| 204  | No content，表示请求成功，但响应报文不含实体的主体部分 |
| 206  | Partial Content，进行范围请求成功                      |

| 3XX  | 重定向（表明浏览器要执行特殊处理）                           |
| ---- | ------------------------------------------------------------ |
| 301  | moved permanently，永久性重定向，表示资源已被分配了新的 URL  |
| 302  | found，临时性重定向，表示资源临时被分配了新的 URL            |
| 303  | see other，表示资源存在着另一个 URL，应使用 GET 方法获取资源（对于301/302/303响应，几乎所有浏览器都会删除报文主体并自动用GET重新请求） |
| 304  | not modified，表示服务器允许访问资源，但请求未满足条件的情况（与重定向无关） |
| 307  | temporary redirect，临时重定向，和302含义类似，但是期望客户端保持请求方法不变向新的地址发出请求 |

| 4XX  | 客户端错误                                                   |
| ---- | ------------------------------------------------------------ |
| 400  | bad request，请求报文存在语法错误                            |
| 401  | unauthorized，表示发送的请求需要有通过 HTTP 认证的认证信息   |
| 403  | forbidden，表示对请求资源的访问被服务器拒绝，可在实体主体部分返回原因描述 |
| 404  | not found，表示在服务器上没有找到请求的资源                  |

| 5XX  | 服务器错误                                                   |
| ---- | ------------------------------------------------------------ |
| 500  | internal sever error，表示服务器端在执行请求时发生了错误     |
| 501  | Not Implemented，表示服务器不支持当前请求所需要的某个功能    |
| 503  | service unavailable，表明服务器暂时处于超负载或正在停机维护，无法处理请求 |

#### 首部字段

| 通用首部          | 作用（请求报文和响应报文都可能使用）                         |
| ----------------- | ------------------------------------------------------------ |
| Cache-Control     | 控制缓存的行为：`no-cache`（强制向服务器再次验证）、`no-store`（不做任何缓存）、`max-age=111111`（资源可缓存最大时间 秒）、`public`（客户端、代理服务器都可利用缓存）、`private`（代理服务器不可用缓存） |
| Connection        | 浏览器想要优先使用的连接类型： `keep-alive close`（开启和关闭持久连接） |
| Date              | 创建报文时间                                                 |
| Pragma            | 只用于请求报文，客户端要求中间服务器不返回缓存的资源         |
| Via               | 代理服务器相关信息，每经过一个代理服务器就会添加相关信息，用逗号分割 |
| Transfer-Encoding | 传输编码方式：`chunked`分块传输                              |
| Upgrade           | 要求客户端使用的升级协议，需配合`Connection: Upgrade`一起使用：`websocket` |
| Warning           | 缓存相关问题的警告                                           |

| 请求首部            | 作用（请求报文专用）                                         |
| ------------------- | ------------------------------------------------------------ |
| Accept              | 能正确接收的媒体类型：`application/json` `text/plain`        |
| Accept-Charset      | 能正确接收的字符集: `unicode-1-1`                            |
| Accept-Encoding     | 能正确接收的编码格式列表：`gzip deflate`                     |
| Accept-Language     | 能正确接收的语言列表：`zh-cn,zh;1=0.9,en,1=0.8`              |
| Authorization       | 客户端认证信息：`Bearer dSdSdFFlsfdjasd123`，一般存token用   |
| Cookie              | 发送给服务器的Cookie信息                                     |
| Expect              | 期待服务端的指定行为                                         |
| From                | 请求方邮箱地址                                               |
| Host                | 服务器的域名，用于区分单台服务器多个域名的虚拟主机，是HTTP/1.1唯一必须包含的字段。 |
| If-Match            | 两端资源标记比较，只有判断条件为真服务端才会接受请求：`If-Mach: "123456`，和服务端文件标记比较 |
| If-Modified-Since   | 本地资源未修改返回 304（比较时间）                           |
| If-None-Match       | 本地资源未修改返回 304（比较标记）                           |
| User-Agent          | 客户端信息                                                   |
| Max-Forwards        | 限制可被代理及网关转发的次数                                 |
| Proxy-Authorization | 向代理服务器发送验证信息                                     |
| Range               | 请求某个内容的一部分，配合`If-Range`使用                     |
| Referer             | 请求发起页面的原始URI                                        |
| TE                  | 传输编码方式                                                 |

| 响应首部           | 作用（响应报文专用）                                    |
| ------------------ | ------------------------------------------------------- |
| Accept-Ranges      | 告知客户端服务器是否可接受范围请求，是`bytes`，否`none` |
| Age                | 资源在代理缓存中存在的时间                              |
| ETag               | 资源标识，资源发生变化时标识也会发生改变                |
| Location           | 客户端重定向到某个 URL                                  |
| Proxy-Authenticate | 向代理服务器发送验证信息                                |
| Server             | 服务器名字：`Apache Nginx`                              |
| WWW-Authenticate   | 获取资源需要的认证方案                                  |
| Set-Cookie         | 需要存在客户端的信息，一般用于识别用户身份              |

| 实体首部         | 作用（补充请求报文或响应报文相关信息）                       |
| ---------------- | ------------------------------------------------------------ |
| Allow            | 资源的正确请求方式：`GET HEAD POST`                          |
| Content-Encoding | 内容的编码格式：`gzip deflate`                               |
| Content-Language | 内容使用的语言：`zh-CN`                                      |
| Content-Length   | request body 长度（即实体主体的大小）：                      |
| Content-Location | 返回数据的备用地址                                           |
| Content-MD5      | Base64加密格式的内容 MD5检验值                               |
| Content-Range    | 响应主体的内容范围                                           |
| Content-Type     | 内容的媒体类型（如'application/json;charset=UTF-8'则会发送预检请求） |
| Expires          | 内容的过期时间                                               |
| Last_modified    | 内容的最后修改时间                                           |



#### HTTPS和HTTP的区别

1. HTTPS协议需要到CA（证书颁发机构）申请证书，一般免费证书很少，需要交费。
2. HTTP协议运行在TCP之上，所有传输的内容都是明文，HTTPS运行在SSL/TLS之上，SSL/TLS运行在TCP之上，所有传输的内容都经过加密的。
3. HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。
4. http的连接很简单，是无状态的；HTTPS协议是由HTTP+SSL协议构建的可进行加密传输、身份认证的网络协议，可以有效的防止运营商劫持，解决了防劫持的一个大问题，比http协议安全。

## Node

#### Node 版本控制

一，查看当前版本

```js
node -v
```

二，清除 **Node.js** 的 **cache**

```js
sudo npm cache clean -f
```

三，使用 **npm** 安装 **n** 模块，**Node** 的多版本管理 **n** 来升级

```js
sudo npm install -g n
```

四，查看 **node** 所有版本

```js
npm view node versions
```

五，升级版本，

```js
// 升级最新版本
sudo n latest

// 升级到稳定版本
sudo n stable

// 升级到具体版本号
sudo n 版本号
```

六，查看版本

```js
node -v
```

